ğŸ“ Dev Log â€” Todayâ€™s Work
---------------------------------------------------
Beginning to intermediate.
---------------------------------
----Functions
What to learn.
So your status for Day 1:
Task	Status
Function basics	âœ”ï¸ Completed
Positional args	âœ”ï¸ Completed
Keyword args	âœ”ï¸ Completed
Default args	âœ”ï¸ Completed
*args	âœ”ï¸ Completed
**kwargs	âœ”ï¸ Completed
Mixed usage	âœ”ï¸ Completed
Return vs print understanding	âœ”ï¸ Completed
Practiced 6â€“10 functions	âœ”ï¸ Completed
Applicative order	â›” Not done yet
Create notes_functions.py	âš ï¸ Partially done (needs skeleton)

What I Learned
â€¢	Variadic Arguments
o	*args collects extra positional arguments into a tuple.
o	**kwargs collects extra keyword arguments into a dictionary.
o	Useful when building flexible functions like your officers_details() example.
â€¢	Why return showed only one output but print showed all
o	A function can only return one value once â€” the moment return runs, the function stops.
o	print() can run multiple times inside the loop, so each keyâ€“value pair gets printed.
o	If you want to return everything, you must build a single object (like a string or dict) and return that.
â€¢	Applicative Order (Python Evaluation Rule)
o	Python evaluates all arguments first before calling the function.
o	Example:
o	func(a(), b())
a() and b() are evaluated before func runs.
o	Helps you understand why some functions run earlier than expected.
â€¢	Notes App Skeleton
o	You created the base structure:
o	def addNote():
o	    pass
o	
o	def listNotes():
o	    pass
o	
o	def deleteNotes():
o	    pass
o	Ready for the next part: adding the applicative logic (how everything connects).
________________________________________
What Challenged Me
â€¢	Grasping the difference between print() vs return in a loop.
â€¢	Fully understanding how Python evaluates arguments before calling the main function.
â€¢	Moving from function skeleton to full application logic in the Notes App.
________________________________________
Next Step
1.	Add proper logic inside:
o	addNote()
o	listNotes()
o	deleteNotes()
2.	Store notes in a list or dictionary.
3.	Make a menu interface:
o	Add note
o	View notes
o	Delete note
o	Exit
4.	Practice building functions that use *args and **kwargs.
________________________________________
Reflection
Todayâ€™s progress shows deeper clarity in function behavior and argument evaluation. You're now understanding not just what Python does â€” but why it behaves that way. The Notes App project will push you into real-world logic flow, which is the bridge from beginner to intermediate Python.


Perfect â€” youâ€™ve **completed 90% of Day 2** already.
Here is **whatâ€™s left + your full daily log** in the exact format you used yesterday.

---

# âœ… **WHAT IS LEFT TO DO FOR DAY 2**

You have:

âœ”ï¸ Created `mini_note_app/` folder
âœ”ï¸ Created `__init__.py`, `helpers.py`, `main.py`
âœ”ï¸ Moved note functions into `helpers.py`
âœ”ï¸ Imported functions into `main.py`
âœ”ï¸ Tested imports

Remaining small tasks:

### **1. Add at least ONE reusable utility function**

Create a file:
`utilities.py`

Inside it, add something simple like:

* `def clear_screen(): pass`
* `def format_title(text): pass`
* `def get_timestamp(): pass`

The point is to *practice modular thinking*, not to build something big.

---

### **2. Practice Python's import styles**

Inside `main.py`, test:

âœ”ï¸ Regular import

```python
import helpers
```

âœ”ï¸ Selective import

```python
from helpers import addNote
```

âœ”ï¸ Import all

```python
from helpers import *
```

âœ”ï¸ Import with alias

```python
import helpers as h
```

This finishes the **import exploration** part of Day 2.

---

### **3. Review how Python finds modules**

Add a quick print in `main.py`:

```python
import sys
print(sys.path)
```

Just run it once to see search paths. Then remove it.

---

After these 3 things, **Day 2 is fully completed**.

---

# ğŸ“ **DAY 2 â€” LOG FOR DOCUMENTATION**

(*Clean, simple, straight to the point â€” same style as Day 1 log*)

---

# **ğŸ“… DAY 2 â€” Modules & Imports (LOG)**

### **What I Learned**

* What a module is (a Python file you can import and reuse)
* How `import` works internally
* The two major import styles:

  * `import module`
  * `from module import name`
* How Python searches for modules using `sys.path`
* Why folder structure is important in backend projects
* How to create reusable helper and utility files
* How to split logic across multiple files

---

### **What I Practiced**

* Created multiple Python files and imported between them
* Tested all import styles (normal import, selective, alias, wildcard)
* Created a `mini_note_app/` folder with:

  * `__init__.py`
  * `helpers.py`
  * `main.py`
* Successfully moved note functions into `helpers.py`
* Imported and called them from `main.py`
* Created a `utilities.py` module to practice modular thinking
* Explored Pythonâ€™s module search path using `sys.path`

---

### **What I Built**

* A properly structured backend-style folder with modules
* `helpers.py` containing all note functions
* `main.py` importing and using the helper functions
* A small utilities module for formatting and support functions
* A clean, working module-based project structure

---

### **End-of-Day Confidence**

By the end of Day 2, I understand:

* How Python imports files
* How to structure backend folders
* How to separate logic into modules
* How to reuse functions across a project

-------------------------------------------------
Here is your **full Day 3 Log** â€” clean, organized, and ready for your documentation.

---

# ğŸ“˜ **Dev Log â€” File Handling & JSON (Day 3 â€” November 14, 2025)**

## **What I Learned**

Today I mastered the foundation of backend file handling:

### ğŸ”¹ **File Opening & Closing**

* How to open files using `open()`.
* Why closing files manually is risky.
* How context managers (`with open()`) automatically close files safely.

### ğŸ”¹ **File Modes**

I learned when and why to use each:

| Mode   | Meaning           | Use Case             |
| ------ | ----------------- | -------------------- |
| `"r"`  | read              | open existing file   |
| `"w"`  | write (overwrite) | create/replace file  |
| `"a"`  | append            | add new text         |
| `"r+"` | read/write        | update existing file |
| `"w+"` | write/read        | overwrite then read  |
| `"a+"` | append/read       | read + add new lines |

### ğŸ”¹ **Reading Files**

* `read(size)` â†’ read controlled chunks
* `readline()` â†’ read line by line
* `readlines()` â†’ read all lines into a list
* Using `.seek(0)` to reset cursor
* Why chunk reading prevents memory overload for large files

### ğŸ”¹ **Writing & Appending**

* `write()` to store new data
* Writing multiple lines
* Rewriting files by looping through content and saving again

### ğŸ”¹ **Copying Files**

* How to copy text files line-by-line
* How to copy binary files (images) using:

  * `"rb"` â†’ read binary
  * `"wb"` â†’ write binary
* How to use chunk sizes (`4096`) when copying large files efficiently

### ğŸ”¹ **JSON Basics**

* JSON stores Python dictionaries as structured data.
* You can read JSON using `json.load()`.
* You can write JSON using `json.dump()`.
* JSON is better than TXT when you need:

  * structure
  * updates
  * lists of objects
  * real backend data patterns

---

## **What Challenged Me**

* Understanding structured JSON handling
* Knowing when to choose each file mode
* Remembering the behavior of `with open()` vs manual `.close()`
* Thinking about how text files vs binary files differ internally

---

## **Next Step**

* Deep-dive into JSON:

  * Loading, dumping, updating files
  * Storing your notes in JSON instead of TXT
* Move your note-taking app from TXT â†’ JSON
* Practice reading/writing dictionary data
* Get ready for **Day 4: Exceptions & Error Handling**







